<!DOCTYPE html>
<html lang="de-DE">
<head>
	<!-- Primary Meta Tags -->
	<title>WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Kesselsteuerung im Automatikmodus mit Hysterese / manueller Steuerung</title>
	<meta name="description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Thermostat für Hausheizung mit Gaskesselsteuerung.">
	<meta name="keywords" content="termostat, digitálny, arduino ide, wemos d1 mini, nodemcu, wifi, esp8266, vykurovanie, kúrenie, wifimanager, webserver, socket, http, web, ip, ipv4, ds18b20, onewire, 1-wire, esp32, nodemcu">
	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://martinius96.github.io/WiFi-termostat/de/">
	<meta property="og:title" content="WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Kesselsteuerung im Automatikmodus mit Hysterese / manueller Steuerung">
	<meta property="og:description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Thermostat für Hausheizung mit Gaskesselsteuerung.">

	<!-- Twitter -->
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://martinius96.github.io/WiFi-termostat/de/">
	<meta property="twitter:title" content="WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Kesselsteuerung im Automatikmodus mit Hysterese / manueller Steuerung">
	<meta property="twitter:description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Thermostat für Hausheizung mit Gaskesselsteuerung.">
	
	<link rel="icon" type="image/png" href="favicon.png">
	<link rel="sitemap" type="application/xml" title="Sitemap" href="../../sitemap.xml" />
	<meta name="google-site-verification" content="UwZZh2EXv3iWUAi_1Z0hLxVCz6ySJ4UdY_BPoLtejwo" />    	
	<meta property='fb:admins' content='100001242570317'>
    	<meta charset="utf-8">
    	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
	<script type="text/javascript">
    		window.smartlook||(function(d) {
    			var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];
    			var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';
    			c.charset='utf-8';c.src='https://rec.smartlook.com/recorder.js';h.appendChild(c);
    		})(document);
    		smartlook('init', 'db50efe9fff280a17db52b82be221240cbbd3dbe');
	</script>    
		<style>
	#right {
  position: absolute;
  right: 0px;
}
	</style>
</head>
<body>
	<div class="container">
  		<div class="row">
    			<div class="col-sm-12">
<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="index.html">WiFi Thermostat</a>
    </div>
    <ul class="nav navbar-nav">
      	<li class="active"><a href="index.html">Überblick</a></li>
	<li><a href="zapojenie.html">Beteiligung</a></li>      
	<li class=""><a href="spustenie.html">Firmware</a></li>
  	<li><a href="json_client.html">JSON-Client</a></li>
      	<li><a href="kontakt.html">Kontakt</a></li>
<a href="../index.html"><img src="https://futbalovysen.sk/wp-content/uploads/slovakia.png" alt="Slovak flag.png, 2,2kB" title="Slovakia" height="32" width="32"></a>	
<a href="../en/index.html"><img src="https://i2.wp.com/facsusa.com/wp-content/uploads/2017/05/Flag-of-England.png?ssl=1" alt="English.png, 2,2kB" title="English" height="32" width="32"></a>
	<li style="float: right; "><a href="https://martinius96.github.io/termostat-ethernet/de/" class="btn btn-danger" role="button" title="Ändern Sie das Projekt in einen Ethernet-Thermostat"><img src="https://i.imgur.com/6dW9TvK.png" width=16px height=16px> <font color="white">Ethernet-Thermostat</font></a></li>
    </ul>
  </div>
</nav>  
<div class="alert alert-success">
	<strong>WiFi-Thermostat-Projekt-Repository mit Maschinencodes für die Zielplattform ESP8266 und ESP32: </strong><a href="https://github.com/martinius96/WiFi-termostat/">Github repo</a>
</div>	
<div class="alert alert-danger">
	Die Firmware WiFi_Thermostat und WiFi_Thermostat_mDNS ist in englischer Sprache für die Mikrocontroller ESP32 und ESP8266 (Espressif Systems) verfügbar. Die experimentelle Version der Basis-Firmware mit manueller Ausgabesteuerung ist nur in slowakischer Sprache verfügbar.
</div>	
<div class="alert alert-info">
 	<strong>Unterstützen Sie das WiFi-Thermostat-Projekt über PayPal. Der Support ermöglicht es Ihnen, in Zukunft neue Funktionen hinzuzufügen und den Quellcode der Anwendung zu öffnen: </strong><a href="https://www.paypal.com/paypalme/chlebovec" class="btn btn-primary" role="button">PayPal donate</a>
</div>	
<span class="label label-default">ESP8266</span>
<span class="label label-primary">ESP32</span>
<span class="label label-success">WiFi</span>
<span class="label label-info">DS18B20</span>
<span class="label label-warning">OneWire</span>
<span class="label label-danger">Dallas</span>
<span class="label label-default">HTML</span>
<span class="label label-primary">Webserver</span>
<span class="label label-success">WebSocket</span>
<span class="label label-info">JSON</span>
<span class="label label-warning">mDNS</span>	
<span class="label label-danger">UART</span>					
  <div class="row">
  <div class="col-sm-4"><center><img src="https://i.imgur.com/koSyFuW.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuern NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F" title="Mikrocontroller steuern NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F"><br><b><a href="https://www.ebay.com/itm/252718027546">NodeMCU (ESP8266)</a></b></center></div>
  <div class="col-sm-4"><center><img src="https://i.imgur.com/FV9xi6K.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuern Wemos D1 Mini - ESP8266-12E / ESP8266-12F" title="Mikrocontroller steuern Wemos D1 Mini - ESP8266-12E / ESP8266-12F"><br><b><a href="https://www.ebay.com/itm/254535886946">Wemos D1 Mini (ESP8266)</a></b></center></div>
  <div class="col-sm-4"><center><img src="https://i.imgur.com/BczG03b.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuernr ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S" title="Mikrocontroller steuern ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S"><br><b><a href="https://www.ebay.com/itm/254953129496">ESP32 DevKit</a></b></center></div>
</div>					
<hr><center><h2>WiFi Thermostat - ESP8266 / ESP32</h2></center><hr>
<p style="text-align: justify;">
Die Softwareimplementierung ist für Mikrocontroller-Plattformen des Herstellers Espressif Systems mit WiFi-Konnektivität ausgelegt.
Unterstützte WiFi (2,4 GHz) ESP8266- und ESP32-Mikrocontroller.
Der WiFi-Thermostat ist über das LAN-Netzwerk, in dem er sich befindet, zugänglich, während er mit einer Weboberfläche ausgestattet ist, die dazu dient, alle Elemente des Thermostats zu konfigurieren und gleichzeitig die aktuellen Zustände zu visualisieren.
Der Thermostat regelt den Kessel auf Basis der gemessenen Solltemperatur und Hysterese unabhängig von der Webapplikation, die zur Konfiguration und Entscheidungsschwelle des Thermostats dient.
Neben der Verfügbarkeit des Thermostats unter einer bestimmten IP-Adresse kann der Thermostat mit einem mDNS-Record ergänzt werden, der innerhalb dieses Multicast-Dienstes eine nur im LAN-Netzwerk erreichbare lokale Domain (hostname.local) generiert.
Die Konfiguration des Thermostats (aus Sicht der Konnektivität) im Heim-WLAN-LAN-Netzwerk wird durch den WiFiManager gesichert, der Daten über das WLAN-Netzwerk (SSID und Passwort) im Flash-Speicher des Mikrocontrollers speichert.
Die Speicherung erfolgt einmalig und das Gerät merkt sich die Konfiguration dauerhaft. Nach dem Herstellen der Konnektivität (Zuweisung einer IP-Adresse vom Router Ihres WLAN-Heimnetzwerks) kann der Thermostat vollständig verwendet werden.
Der HTTP-Webserver, der auf dem ESP8266 / ESP32-Mikrocontroller läuft, ermöglicht das Ausführen mehrerer unabhängiger HTML-Seiten, die informativ oder sogar funktional sein können.
</p>
<b>In Bezug auf die Hardware verwendet das Projekt:</b>
<li>ESP8266 / ESP32</li>
<li>Temperatursensor DS18B20 am OneWire-Bus</li>
<li>Relais SRD-5VDC-SL-C / OMRON G3MB-202P zur Kesselschaltung (Active-LOW-Signal)</li>
<hr>
<b> HTML-Seiten mit ESP8266 / ESP32: </b>
<li> <b> / </b> - Grundseite mit Formular, aktueller Logikausgang für das Relais, aktuelle und Solltemperatur, Hysterese </li>
<li> <b> /action.html </b> - verarbeitet Werte aus dem Formular, schreibt sie in den emulierten EEPROM-Speicher, leitet den Benutzer zurück zur Stammseite </li>
<li> <b> /get_data.json </b> - verteilt Daten zur aktuellen Temperatur, Referenztemperatur und Hysterese an Dritte (Computer, Mikrocontroller, anderer Client ...) im JSON-Format - kann mit dem Beispiel verwendet werden JSON-Client, der Daten an MQTT Broker senden kann, zum Beispiel an die Hausautomation </li>
<hr>
<b> Erweitert mit HTML-Seiten in einer experimentellen Version mit manuellem Modus, falls vorhanden: </b>
<li> <b> /on.html </b> - Ausgabe im manuellen Modus dauerhaft einschalten </li>
<li> <b> /vyp.html </b> - Ausgabe im manuellen Modus dauerhaft deaktivieren </li>
<li> <b> /automat.html </b> - Modus auf Automatik ändern (verwendet Hysterese und Zieltemperatur) </li>
<li> <b> /manual.html </b> - Wechseln Sie in den manuellen Modus (permanente EIN / AUS-Hardsteuerung) </li>
<hr>	
<p style="text-align: justify;">		
<b> Die Auflösung des DS18B20 Sensors während der Messung beträgt 12 Bit, was durch die Temperaturauflösung bei 0,0625 °C angezeigt wird, was ebenfalls ein minimaler Schritt zwischen den verschiedenen Messwerten ist.
Daten über den OneWire-Bus können bei Bedarf in 500 bis 1000 ms an den Mikrocontroller zurückgesendet werden, je nach Anzahl der Sensoren, Buslänge. </b>
Das im Projekt verwendete elektromagnetische Relais SRD-5VDC-SL-C ermöglicht das Schalten bis 10A bei 230V - Leistung 2300W.
Beim Schalten eines Gleichstromkreises (Last) können 300W (10A bei 30V DC) geschaltet werden.
Alternativ ist das OMRON G3MB-202P SSR-Relais voll kompatibel zum Schaltplan, der nur für nicht induktive Lasten und ausschließlich für Wechselstromkreise geeignet ist.
Maximale Schaltleistung 460W (230V, 2A). <b> Der Thermostat kann das ganze Jahr über verwendet werden. Im Falle einer unnötigen Steuerung ist es möglich, den Ausgang physisch zu trennen und den Thermostat als WLAN-Thermometer zu verwenden, um Daten aus dem Raum zu erhalten, in dem er sich befindet. </b>
</p>
<hr>
<p style="text-align: justify;">
Bei Firmware mit Unterstützung für die manuelle Steuerung des GPIO-Ausgangs des ESP-Mikrocontrollers kann der Thermostat physisch ausgeschaltet werden, ohne ihn von der Relaisklemme trennen zu müssen.
Die Thermostatlogik wird unabhängig vom Webserver und angeschlossenen Clients alle 10 Sekunden ausgeführt, für die Ausführung ist keine Keep-Alive-Verbindung erforderlich.
Bei jeder Ausführung der Logik schreibt der Thermostat auch Informationen über die aktuelle IP-Adresse oder den mDNS-Record (bei Verwendung mit mDNS-Firmware) auf den UART-Thermostat und gibt so dem Benutzer Auskunft darüber, wo der Thermostat mit seinem Webinterface im LAN erreichbar ist Netzwerk.
Darüber hinaus listet es auch den dynamischen freien Speicher - HEAP, der von 40 bis 44 kB reicht, sowie den aktuellen Status der Ausgabe mit Benachrichtigung über die Änderung, falls sie auftritt -> (wenn die Entscheidungsschwelle nach + oder nach - fließt) ).
<b> Die 3V3-GPIO-Betriebslogik der ESP8266- und ESP32-Mikrocontroller reicht für ein digitales Änderungssignal aus, aber das Relais muss mit 5 V von VUSB bzw. VIN versorgt werden. </b>
</p>
<b> Die Webschnittstelle des WiFi-Thermostats ermöglicht Ihnen: </b>
<li> Sehen Sie in Echtzeit die Temperatur des DS18B20-Sensors, die Betriebszeit des Geräts, den Ausgabewert mit dynamischer Änderung, die aktuell eingestellten Konfigurationsdaten für den Thermostat, d. Solltemperatur und Hysterese </li>
<li>Ändern Sie die Ziel-(Referenz-)Temperatur <del>im Bereich von 5 bis 50 °C in Schritten von 0,25 °C</del> <img src="https://i.imgur.com/zMsp0cr.png" width="20px" height="20px" data-toggle="tooltip2" data-placement="right" title="Umfang in Version 1.0.2 aufgrund der Unterstützung von Nicht-Dezimalkomma für die Eingabetypnummer auf Android-Betriebssystem entfernt"></li>
<li> Ändern <del>Hysterese von 0 bis 10 ° C in Schritten von 0,25 ° C</del> <img src="https://i.imgur.com/zMsp0cr.png" width="20px" height="20px" data-toggle="tooltip2" data-placement="right" title="Umfang in Version 1.0.2 aufgrund der Unterstützung von Nicht-Dezimalkomma für die Eingabetypnummer auf Android-Betriebssystem entfernt"></li>
<div class="alert alert-danger">
  <strong>Die Programmimplementierung eines Thermostats mit automatischer und manueller Leistungsregelung ist experimentell!</strong>
</div>
<b> Kessel EIN / AUS-Steuerung - Automatikmodus: </b>
<li>Beispiel für EIN / AUS der Heizungssteuerung - <font color = "red"> VISUALISIERUNG IST NICHT TEIL DES PROJEKTS </font> </li>
<li>Der Kessel ist aktiv, solange die Solltemperatur + Hysterese erreicht ist </li>
<li> Die Visualisierung von Wassertemperaturen zeigt die sogenannte Heizlauf und anschließendes Abkühlen des Wassers bis die Heizung wieder aktiviert wird, wenn die gemessene Temperatur unter der eingestellten Solltemperatur liegt - Hysterese </li>
<img src="https://i.imgur.com/IDWLuOr.png" style="display: block; max-width: 100%; height: auto;" alt="ZAP/VYP regulácia kotla s hysterézou" title="ZAP/VYP regulácia kotla s hysterézou">   
<p style="text-align: justify;">
<b> In der Basisversion des WiFi-Thermostats (ohne mDNS-Aufzeichnung) wurde ein manueller Steuermodus (hart EIN / AUS) implementiert mit der Möglichkeit zwischen manuellem und automatischem Modus umzuschalten. </b>
Die Weboberfläche ist für größere und kleinere Bildschirme ausgelegt. Es ist reaktionsschnell und unterstützt hochauflösende Breitbild-Bildschirme sowie mobile Geräte.
Die Schnittstelle verwendet importierte CSS-Stile des Bootstrap-Frameworks von einem externen CDN-Server, der das clientseitige Gerät lädt, wenn eine Seite geöffnet wird, die auf ESP ausgeführt wird.
Durch den Import von CSS-Stilen von einem externen Server wird die Strom- und Speicherbelastung des Mikrocontrollers reduziert.
</p>
<hr>
<p style="text-align: justify;">
Um die eingestellten Werte des Thermostats auch nach einem Stromausfall beizubehalten, werden diese im EEPROM-Speicher ESP gespeichert, der im Flash-Speicher emuliert wird, da die Plattform keinen physikalischen EEPROM-Chip (Speicher) besitzt.
Referenztemperatur auf Offset 10, Hysterese auf Offset 100. Jeder der Werte belegt maximal 5B im EEPROM-Speicher + das Endezeichen.
Die Daten werden erst beim Senden des HTML-Formulars überschrieben, der Betrieb des Thermostats schont den EEPROM-Speicher für maximale Haltbarkeit.
Der Zustand des Ausgangs existiert nur im RAM-Speicher, wo er bei der Änderung überschrieben wird. Der Wert wird nicht im emulierten EEPROM-Speicher im Flash-Speicher abgelegt.
</p>
<hr>
<p style="text-align: justify;">
Wenn das Gerät beim ersten Start nichts auf den genannten EEPROM-Offsets gespeichert hat, wird das automatische Schreiben mit Standardwerten durchgeführt - Referenz: 20,25 ° C, Hysterese 0,00 ° C. Dadurch wird sichergestellt, dass der Thermostat auf Mikrocontrollern arbeiten kann, die nichts im EEPROM-Speicher geschrieben haben - ausfallsichere Lösung.
ESP8266 und ESP32 verwenden die Funktion EEPROM.put(), um in den EEPROM-Speicher zu schreiben, der jeden Datentyp unterstützt, und EEPROM.commit(), um das Schreiben in den Ziel-Offset zu bestätigen.
Die Implementierung verwendet den Datentyp float() für eine 32-Bit-Zahl, die im EEPROM gespeichert wird und zur Referenz-(Soll-)Temperatur sowie Hysterese gehört.
Mit dem Refresh-Meta-Tag aktualisiert der Webserver alle 30 Sekunden die gesamte HTML-Seite und die JavaScript-Zeit bis zum Refresh wird ebenfalls per Javascript in die HTML-Seite geschrieben.
Zu diesem Zeitpunkt ist es notwendig, die Änderung für den Thermostaten zu schreiben, da sonst die Eingabefenster für numerische Eingaben in das Formular beim Aktualisieren der Seite zurückgesetzt werden.
Da die eingebaute Ethernet-Bibliothek die Verwendung eines asynchronen Webservers nicht beinhaltet (der beispielsweise mit den Espressif ESP8266 / ESP32-Mikrocontrollern verwendet werden kann), ist es erforderlich, die gesamte Seite neu zu schreiben, da diese Implementierung 1:1 ist mit dem originalen Ethernet-Thermostat.
</p>
<hr>
<p style="text-align: justify;">
Die sich hauptsächlich ändernden dynamischen Daten sind der aktuelle Wert der Ausgabe - <b> <font color = "#27AE60"> EIN </font> </b> / <b> <font color = "red"> AUS </font> </b>, die den Bediener über den aktuellen Zustand der Ausgabe zusammen mit der Farbcodierung informiert.
Da die Systemlogik unabhängig vom Webserver ausgeführt wird, kann sich die Ausgabe bereits in einem anderen Zustand befinden als aktuell in der Webanwendung aufgelistet. Die Ausgabeänderung wird z. B. sofort auf den UART-Monitor geschrieben.
Auf der Website des Thermostats findet der Benutzer auch Informationen über die Betriebszeit des Geräts (wie lange es in Betrieb war), d. Zeit in Tagen, Stunden, Minuten und Sekunden. <b>Der Thermostat ist nur für Innentemperaturen gedacht!</b> (über 0°C), an die die Systemlogik angepasst ist!
Der Thermostat kann verwendet werden, um einen vorhandenen Raumthermostat zu ersetzen, die Heizung im Aquarium / Terrarium kann vorübergehend ersetzt werden, um eine konstante Temperatur zu halten.
</p>
<div class="alert alert-danger">
	<strong>Der Autor des WiFi-Thermostats ist nicht verantwortlich für die Funktionalität des Thermostats, Kesselausfall, Stromschlag aufgrund einer unsachgemäßen Installation des Thermostats im Netzwerk. </strong> Der Thermostat wird unter der MIT-Lizenz vertrieben.
</div>	
<b> Hauptseite zur Änderung der Zieltemperatur und der Hysterese - Demo auf: </b>
<div class="alert alert-info">
	<strong> Beispieldaten </strong>
<li> <b>Zieltemperatur: </b> 22.75 °C</li>
<li> <b> Hysterese: </b> 0.25 ° C </li>
<li> <b>Messdaten: </b> 22.49 ° C </li>
<li> <b> Ausgabe: </b>  <font color="#27AE60">EIN</font></li>
	<hr>
	<p style="text-align: justify;">
		Der Thermostat heizt ab einer gemessenen Temperatur von 22.49 °C und darunter.
Wenn die Temperatur 23.01 °C erreicht, wird der Ausgang ausgeschaltet, das Melderelais öffnet und der Gaskessel hört auf zu heizen.
Das Aufheizen und Abkühlen des Raumes, in dem die Messungen durchgeführt werden, erfolgt. 
Der Thermostat wird erst wieder aktiviert, wenn die Temperatur 22.49 °C oder niedriger erreicht.
	</p>	
</div>

<b>Hauptseite zur Änderung der Solltemperatur und Hysterese:</b>
<img src="https://i.imgur.com/dBXiDLN.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi-Thermostat - Hauptübersicht mit Änderung von Solltemperatur und Hysterese" title="WiFi-Thermostat - Hauptübersicht mit Änderung von Solltemperatur und Hysterese">        			

<b>Verarbeitungsprozess der eingegebenen Daten (Nutzerumleitung):</b>
<img src="https://i.imgur.com/QaGCYGh.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi-Thermostat - Datenverarbeitung aus HTML-Formular" title="WiFi-Thermostat - Datenverarbeitung aus HTML-Formular">        			

<b>JSON-Webserverausgabe im Browser / Client über Websocket:</b>
<center><img src="https://i.imgur.com/iqxV12k.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi thermostat - JSON output" title="WiFi thermostat - JSON output"></center>        		

<b>Ausgabe an UART-Monitor - Systemlogik + IP-Adresse einstellen, mDNS-Record:</b>
<center>
<img src="https://i.imgur.com/gWm9izE.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - UART - ESP8266 - mDNS protokollieren, IP-Adresse des Thermostats" title="WiFi termostat - UART - ESP8266 - mDNS protokollieren, IP-Adresse des Thermostats">
</center>        		
<div class="alert alert-info">
<b> Eine erweiterte Version des WiFi-Thermostats umfasst: </b>
<li> Bearbeitbarer Quellcode (.ino) </li>
<li> Verfügbare Sensoren SHT21, SHT31, DHT22, BME280, BMP280 für die Kesselsteuerung </li>
<li> Kühlmodus (inverse Logik zum Heizthermostat) </li>
<li> Basic OTA, OTA Web Updater, Eleganter Remote OTA </li>
<li> Möglichkeit, die Ausgabe über Callbacks zu steuern, die von UDP-Datagrammen über UDP-Clients (Packet Sender) aufgerufen werden. </li>
<li> Interaktion mit Amazon Alexa Echo Dot mit der Möglichkeit der Sprachsteuerung des Thermostats (UDP-Rückrufe) </li>
<li> Möglichkeit zur Veröffentlichung von Daten an MQTT Broker / per HTTP / HTTPS-Anfrage an einen entfernten Webserver mit Datenspeicherung in einer MySQL-Datenbank (ohne JSON-Client) </li>
</div>
<hr><center><h4>Verfügbare Bibliotheken für Mikrocontroller (ESP)</h4></center><hr>
<div class="alert alert-danger">
	Bibliotheksarchiv (.zip) expandieren zu <strong>C:/Users/[User]/Documents/Arduino/libraries</strong>
</div>
<div class="table-responsive">   
<table class="table" style="border: 1px solid black;">
<thead>
<tr>
<th style="width: 25%">Name der Bibliothek</th>
<th style="width: 50%">Bibliotheksfunktion</th>
<th style="width: 25%">Herunterladen</th>
</tr>
</thead>
<tbody>
<tr>
<td style="width: 25%"><b>Dallas</b></td>
<td style="width: 50%">
<p style="text-align: justify;">
Bibliothek für ESP8266- und ESP32-Mikrocontroller.
Es ermöglicht die Kommunikation mit dem Dallas DS18B20-Sensor auf dem OneWire-Bus. Kommunikationsmöglichkeit nach normaler oder parasitärer Verbindung. 
</p>
</td>
<td style="width: 25%"><a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/martinius96/termostat-ethernet/tree/master/src/dallas" class="btn btn-success" role="button">Herunterladen</a></td>
</tr>
<tr>
<td style="width: 25%"><b>WiFiManager</b></td>
<td style="width: 50%">
<p style="text-align: justify;">
Bibliothek für ESP8266- und ESP32-Mikrocontroller.
Erstellt einen Zugangspunkt (AP) und ein Captive-Portal zum Konfigurieren eines WLAN-Thermostats in einem WLAN-Heimnetzwerk.
</p>
</td>
<td style="width: 25%"><a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/martinius96/WiFi-termostat/tree/main/src/WiFiManager-0.16.0" class="btn btn-success" role="button">Herunterladen</a></td>
</tr>
<tr>
<td style="width: 25%"><b>DNS Server</b></td>
<td style="width: 50%">
<p style="text-align: justify;">
ESP32-Mikrocontroller-Bibliothek.
Erforderlich, damit die WiFiManager-Bibliothek ordnungsgemäß funktioniert. 
</p>
</td>
<td style="width: 25%"><a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/martinius96/WiFi-termostat/tree/main/src/DNSServer---esp32-master" class="btn btn-success" role="button">Herunterladen</a></td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3><font color="#2ECC71">WiFi thermostat - Quellcode - ESP8266</font></h3>
<pre style="background-color:#2ECC71;">
/*|----------------------------------------------------------|*/
/*|HTTP webserver - WiFi thermostat - ESP8266 + DS18B20      |*/
/*|AUTHOR: Martin Chlebovec                                  |*/
/*|EMAIL: martinius96@gmail.com                              |*/
/*|DONATE: paypal.me/chlebovec                               |*/
/*|----------------------------------------------------------|*/

#include &lt;ESP8266WiFi.h>
#include &lt;ESP8266WebServer.h>
#include &lt;WiFiManager.h>
ESP8266WebServer server(80);
#include &lt;DNSServer.h>
#include &lt;EEPROM.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h>

#define ONE_WIRE_BUS 5 //D1
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensorsA(&oneWire);
const int rele = 4; //D2
unsigned long cas = 0;
String stav = "OFF";
float teplota; s
long day = 86400000; // 86400000 milliseconds in a day
long hour = 3600000; // 3600000 milliseconds in an hour
long minute = 60000; // 60000 milliseconds in a minute
long second =  1000; // 1000 milliseconds in a second
float rezim;
boolean isFloat(String tString) {
  String tBuf;
  boolean decPt = false;

  if (tString.charAt(0) == '+' || tString.charAt(0) == '-') tBuf = &tString[1];
  else tBuf = tString;

  for (int x = 0; x &lt; tBuf.length(); x++)
  {
    if (tBuf.charAt(x) == '.' || tBuf.charAt(x) == ',') {
      if (decPt) return false;
      else decPt = true;
    }
    else if (tBuf.charAt(x) &lt; '0' || tBuf.charAt(x) > '9') return false;
  }
  return true;
}

void writeString(char add, float data)
{
  EEPROM.put(add, (data * 1000));
  EEPROM.commit();
}


float read_String(char add)
{
  float payload = 0;
  float data = EEPROM.get(add, payload);
  return (data / 1000);
}

void handleRoot() {
  int days = millis() / day ;                                //number of days
  unsigned int hours = (millis() % day) / hour;                       //the remainder from days division (in milliseconds) divided by hours, this gives the full hours
  unsigned int minutes = ((millis() % day) % hour) / minute ;         //and so on...
  unsigned int seconds = (((millis() % day) % hour) % minute) / second;
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta name='author' content='Martin Chlebovec'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='30'; />");
  stranka += F("&lt;meta name='viewport' content='width=device-width, initial-scale=1'>");
  stranka += F("&lt;link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css'>");
  stranka += F("&lt;script type='text/javascript'> window.smartlook||(function(d) {"); 
  stranka += F("var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];");
  stranka += F("var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';");
  stranka += F("c.charset='utf-8';c.src='https://rec.smartlook.com/recorder.js';h.appendChild(c); })(document);"); 
  stranka += F("smartlook('init', '63ff3bf4db2f85029b19856425a4f2086533c9e6');"); 
  stranka += F("&lt;/script>");  
  stranka += F("&lt;script type='text/javascript'>");
  stranka += F("var timeleft = 30;");
  stranka += F("var downloadTimer = setInterval(function(){");
  stranka += F("if(timeleft &lt;= 0){");
  stranka += F("clearInterval(downloadTimer);");
  stranka += F("document.getElementById(\"countdown\").innerHTML = \"Refreshing...\";");
  stranka += F("} else {");
  stranka += F("document.getElementById(\"countdown\").innerHTML = timeleft + \" seconds to refresh\";");
  stranka += F("}");
  stranka += F("timeleft -= 1;");
  stranka += F("}, 1000);");
  stranka += F("&lt;/script>");
  stranka += F("&lt;title>WiFi thermostat - ESP8266&lt;/title>");
  stranka += F("&lt;/head>");
  stranka += F("&lt;body>");
  stranka += F("&lt;center>&lt;h3>WiFi thermostat - ESP8266:&lt;/h3>");
  if (rezim == 0.00) {
    stranka += F("&lt;form action='/action.html' method='post'>");
    stranka += "&lt;b>Target temperature:&lt;/b>&lt;br>&lt;input type='text' id='fname' name='fname' min='5' max='50' step='0.25' value=" + String(read_String(10)) + ">&lt;br>";
    stranka += "&lt;b>Hysteresis:&lt;/b>&lt;br>&lt;input type='text' id='fname2' name='fname2' min='0' max='10' step='0.25' value=" + String(read_String(100)) + ">&lt;br>";
    stranka += F("&lt;input type='submit' class='btn btn-success' value='Send'>");
    stranka += F("&lt;/form>");
    stranka += F("&lt;a href='manual.html' class='btn btn-primary' role='button'>Manual mode&lt;/a>&lt;hr>");
  } else if (rezim == 1.00) {
    if (stav == "ON") {
      stranka += F("&lt;a href='vyp.html' class='btn btn-danger' role='button'>Turn off&lt;/a>&lt;br>");
    }
    if (stav == "OFF") {
      stranka += F("&lt;a href='zap.html' class='btn btn-success' role='button'>Turn on&lt;/a>&lt;br>");
    }
    stranka += F("&lt;a href='automat.html' class='btn btn-primary' role='button'>Automatic mode&lt;/a>&lt;hr>");
  }
  if (stav == "ON") {
    stranka += F("&lt;b>&lt;font color='green'>Output: ON&lt;/font>&lt;/b>");
  }
  if (stav == "OFF") {
    stranka += F("&lt;b>&lt;font color='red'>Output: OFF&lt;/font>&lt;/b>");
  }
  stranka += F("&lt;div id=\"countdown\">&lt;/div>");
  stranka += F("&lt;b>Current sensor DS18B20 temperature:&lt;/b> ");
  stranka += String(teplota);
  stranka += F(" °C");
  stranka += F("&lt;hr>");
  stranka += F("&lt;b>Uptime: &lt;/b>");
  stranka += String(days);
  stranka += F("d");
  stranka += F(" ");
  stranka += String(hours);
  stranka += F("h");
  stranka += F(" ");
  stranka += String(minutes);
  stranka += F("m");
  stranka += F(" ");
  stranka += String(seconds);
  stranka += F("s");
  stranka += F("&lt;h3>Author: Martin Chlebovec - martinius96@gmail.com - https://martinius96.github.io/WiFi-termostat/en/&lt;/h3>");
  stranka += F("&lt;h4>Free version - 1.0.4 build: 06. Oct. 2021&lt;/h4>");
  stranka += F("&lt;/center>");
  stranka += F("&lt;/body>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}

void handleBody() {
  if (server.hasArg("fname")) {
    String target_temp = server.arg("fname");
    // float cielova_teplota = target_temp.toFloat();

    if (isFloat(target_temp)) {
      float cielova_teplota = target_temp.toFloat();
      writeString(10, cielova_teplota);
    } else {
      Serial.println(F("No number was entered in the input according to the target temperature!"));
      Serial.println(F("Writing into EEPROM prohibited!"));
    }
  }
  if (server.hasArg("fname2")) {
    String hysteresis = server.arg("fname2");
    if (isFloat(hysteresis)) {
      float hystereza = hysteresis.toFloat();
      writeString(100, hystereza);
    } else {
      Serial.println(F("No number was entered in the input according to the hysteresis!"));
      Serial.println(F("Writing into EEPROM prohibited!"));
    }
  }
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='5; url=/' />");
  stranka += F("&lt;title>WiFi thermostat - ESP8266 - data processing&lt;/title>");
  stranka += F("&lt;/head>");
  stranka += F("&lt;body>");
  stranka += F("&lt;center>&lt;h3>Server received data from HTML form:&lt;/h3>");
  stranka += "&lt;li>&lt;b>Target temperature: &lt;/b>" + String(read_String(10)) + " °C&lt;/li>";
  stranka += "&lt;li>&lt;b>Hysteresis: &lt;/b>" + String(read_String(100)) + " °C&lt;/li>";
  stranka += F("&lt;b>Redirecting... Please wait&lt;/b>&lt;/center>");
  stranka += F("&lt;/body>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}

void handleGet() {
  String stranka = "{\n";
  stranka += F("\"Hysteresis\":");
  stranka += String(read_String(100));
  stranka += F(",\n");
  stranka += F("\"Target_Temperature\":");
  stranka += String(read_String(10));
  stranka += F(",\n");
  stranka += F("\"Actual_Temperature\":");
  stranka += String(teplota) + "\n";
  stranka += F("}\n");
  server.send(200, "application/json", stranka);
}

void handleZAP() {
  stav = "ON";
  digitalWrite(rele, LOW);
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='0; url=/' />");
  stranka += F("&lt;/head>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}

void handleAuto() {
  writeString(150, 0.00);
  rezim = read_String(150);
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='0; url=/' />");
  stranka += F("&lt;/head>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}
void handleManual() {
  writeString(150, 1.00);
  rezim = read_String(150);
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='0; url=/' />");
  stranka += F("&lt;/head>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}
void handleVYP() {
  stav = "OFF";
  digitalWrite(rele, HIGH);
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='0; url=/' />");
  stranka += F("&lt;/head>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}
void setup() {
  Serial.begin(115200);
  WiFiManager wifiManager;
  wifiManager.autoConnect("WiFi_TERMOSTAT_AP");
  EEPROM.begin(512);  //Initialize EEPROM
  float a = read_String(10);
  float b = read_String(100);
  float c = read_String(150);
  if (isnan(a)) {
    writeString(10, 20.25);
  }
  if (isnan(b)) {
    writeString(100, 0.25);
  }
  if (isnan(c)) {
    writeString(150, 0.00);
  }
  sensorsA.begin();
  pinMode(rele, OUTPUT);
  digitalWrite(rele, HIGH);
  sensorsA.requestTemperatures();
  delay(750);
  Serial.println(F("WiFi thermostat - Author: Martin Chlebovec"));
  Serial.println("");
  Serial.println(F("WiFi connected."));
  Serial.println(F("IP address: "));
  Serial.println(WiFi.localIP());
  server.on("/", handleRoot);
  server.on("/get_data.json", handleGet);
  server.on("/automat.html", handleAuto);
  server.on("/manual.html", handleManual);
  server.on("/zap.html", handleZAP);
  server.on("/vyp.html", handleVYP);
  server.on("/action.html", HTTP_POST, handleBody);
  server.begin();
}

void loop() {
  if ((millis() - cas) >= 10000 || cas == 0) {
    cas = millis();
    teplota = sensorsA.getTempCByIndex(0);
    Serial.println();
    Serial.println(F("----------------------------------------------"));
    Serial.print(F("IP address of ESP8266 thermostat: "));
    Serial.print(WiFi.localIP());
    Serial.print(F(", for access via mDNS use http://"));
    Serial.print(WiFi.localIP());
    Serial.println(F("/"));
    Serial.print(F("Free HEAP: "));
    Serial.print(ESP.getFreeHeap());
    Serial.println(F(" B"));
    Serial.print(F("Actual DS18B20 temperature: "));
    Serial.print(String(teplota));
    Serial.println(F(" °C"));
    sensorsA.requestTemperatures();
    rezim = read_String(150);
    if (rezim == 0.00) {
      float cielova_teplota = read_String(10);
      float  hystereza = read_String(100);
      float minus_hystereza_teplota = (-1 * hystereza);
      float rozdiel = cielova_teplota - teplota; //21 - 20
      if (rozdiel > hystereza) {
        Serial.println(F("Output ON"));
        stav = "ON";
        digitalWrite(rele, LOW);
      } else if (rozdiel &lt; minus_hystereza_teplota) {
        Serial.println(F("Output OFF"));
        stav = "OFF";
        digitalWrite(rele, HIGH);
      } else {
        Serial.println(F("Difference between the target and actual temperature is not above or below the hysteresis. The output status does not change."));
        Serial.print(F("Actual output state: "));
        Serial.println(stav);
      }
    } else {
      Serial.print(F("Manual operation mode is used, output status: "));
      Serial.println(stav);
    }
  }
  server.handleClient();
  yield();
}

</pre>
<h3><font color="#3498DB">WiFi thermostat - Quellcode - ESP32</font></h3>
<pre style="background-color:#3498DB;">
/*|----------------------------------------------------------|*/
/*|HTTP webserver - WiFi thermostat - ESP32 + DS18B20        |*/
/*|AUTHOR: Martin Chlebovec                                  |*/
/*|EMAIL: martinius96@gmail.com                              |*/
/*|DONATE: paypal.me/chlebovec                               |*/
/*|----------------------------------------------------------|*/

#include &lt;WiFi.h>
#include &lt;WebServer.h>
#include &lt;WiFiManager.h>
#include &lt;ESPmDNS.h>
WebServer server(80);
#include &lt;EEPROM.h>
#include &lt;OneWire.h>
#include &lt;DallasTemperature.h>

#define ONE_WIRE_BUS 23
OneWire oneWire(ONE_WIRE_BUS);
DallasTemperature sensorsA(&oneWire);
const int rele = 22; //D2
unsigned long cas = 0;
String stav;
float teplota;
long day = 86400000; // 86400000 milliseconds in a day
long hour = 3600000; // 3600000 milliseconds in an hour
long minute = 60000; // 60000 milliseconds in a minute
long second =  1000; // 1000 milliseconds in a second

boolean isFloat(String tString) {
  String tBuf;
  boolean decPt = false;

  if (tString.charAt(0) == '+' || tString.charAt(0) == '-') tBuf = &tString[1];
  else tBuf = tString;

  for (int x = 0; x &lt; tBuf.length(); x++)
  {
    if (tBuf.charAt(x) == '.' || tBuf.charAt(x) == ',') {
      if (decPt) return false;
      else decPt = true;
    }
    else if (tBuf.charAt(x) &lt; '0' || tBuf.charAt(x) > '9') return false;
  }
  return true;
}

void writeString(char add, float data)
{
  EEPROM.put(add, (data * 1000));
  EEPROM.commit();
}


float read_String(char add)
{
  float payload = 0;
  float data = EEPROM.get(add, payload);
  return (data / 1000);
}

void handleRoot() {
  int days = millis() / day ;                                //number of days
  unsigned int hours = (millis() % day) / hour;                       //the remainder from days division (in milliseconds) divided by hours, this gives the full hours
  unsigned int minutes = ((millis() % day) % hour) / minute ;         //and so on...
  unsigned int seconds = (((millis() % day) % hour) % minute) / second;
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta name='author' content='Martin Chlebovec'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='30'; />");
  stranka += F("&lt;meta name='viewport' content='width=device-width, initial-scale=1'>");
  stranka += F("&lt;link rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css'>");
  stranka += F("&lt;script type='text/javascript'> window.smartlook||(function(d) {"); 
  stranka += F("var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];");
  stranka += F("var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';");
  stranka += F("c.charset='utf-8';c.src='https://rec.smartlook.com/recorder.js';h.appendChild(c); })(document);"); 
  stranka += F("smartlook('init', '63ff3bf4db2f85029b19856425a4f2086533c9e6');"); 
  stranka += F("&lt;/script>");
  stranka += F("&lt;script type='text/javascript'>");
  stranka += F("var timeleft = 30;");
  stranka += F("var downloadTimer = setInterval(function(){");
  stranka += F("if(timeleft &lt;= 0){");
  stranka += F("clearInterval(downloadTimer);");
  stranka += F("document.getElementById(\"countdown\").innerHTML = \"Refreshing...\";");
  stranka += F("} else {");
  stranka += F("document.getElementById(\"countdown\").innerHTML = timeleft + \" seconds to refresh\";");
  stranka += F("}");
  stranka += F("timeleft -= 1;");
  stranka += F("}, 1000);");
  stranka += F("&lt;/script>");
  stranka += F("&lt;title>WiFi thermostat - ESP32&lt;/title>");
  stranka += F("&lt;/head>");
  stranka += F("&lt;body>");
  stranka += F("&lt;center>&lt;h3>Enter datas for web server:&lt;/h3>");
  stranka += F("&lt;form action='/action.html' method='post'>");
  stranka += "&lt;b>Target temperature:&lt;/b>&lt;br>&lt;input type='text' id='fname' name='fname' min='5' max='50' step='0.25' value=" + String(read_String(10)) + ">&lt;br>";
  stranka += "&lt;b>Hysteresis:&lt;/b>&lt;br>&lt;input type='text' id='fname2' name='fname2' min='0' max='10' step='0.25' value=" + String(read_String(100)) + ">&lt;br>";
  stranka += F("&lt;input type='submit' class='btn btn-success' value='Send'>");
  stranka += F("&lt;/form>&lt;hr>");
  if (stav == "ON") {
    stranka += F("&lt;b>&lt;font color='green'>Output: ON&lt;/font>&lt;/b>");
  }
  if (stav == "OFF") {
    stranka += F("&lt;b>&lt;font color='red'>Output: OFF&lt;/font>&lt;/b>");
  }
  stranka += F("&lt;div id=\"countdown\">&lt;/div>");
  stranka += F("&lt;b>Current sensor DS18B20 temperature:&lt;/b> ");
  stranka += String(teplota);
  stranka += F(" °C");
  stranka += F("&lt;hr>");
  stranka += F("&lt;b>Uptime: &lt;/b>");
  stranka += String(days);
  stranka += F("d");
  stranka += F(" ");
  stranka += String(hours);
  stranka += F("h");
  stranka += F(" ");
  stranka += String(minutes);
  stranka += F("m");
  stranka += F(" ");
  stranka += String(seconds);
  stranka += F("s");
  stranka += F("&lt;h3>Author: Martin Chlebovec - martinius96@gmail.com - https://martinius96.github.io/WiFi-termostat/en/&lt;/h3>");
  stranka += F("&lt;h4>Free version - 1.0.4 build: 10. Oct. 2021&lt;/h4>");
  stranka += F("&lt;/center>");
  stranka += F("&lt;/body>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}

void handleBody() {
  if (server.hasArg("fname")) {
    String target_temp = server.arg("fname");
    // float cielova_teplota = target_temp.toFloat();

    if (isFloat(target_temp)) {
      float cielova_teplota = target_temp.toFloat();
      writeString(10, cielova_teplota);
    } else {
      Serial.println(F("No number was entered in the target temperature input field!"));
      Serial.println(F("Datas will be not stored in EEPROM!"));
    }
  }
  if (server.hasArg("fname2")) {
    String hysteresis = server.arg("fname2");
    if (isFloat(hysteresis)) {
      float hystereza = hysteresis.toFloat();
      writeString(100, hystereza);
    } else {
      Serial.println(F("No number was entered in the hysteresis input field!"));
      Serial.println(F("Datas will be not stored in EEPROM!"));
    }
  }
  String stranka = F("&lt;!DOCTYPE html>");
  stranka += F("&lt;html>");
  stranka += F("&lt;head>");
  stranka += F("&lt;meta charset='utf-8'>");
  stranka += F("&lt;meta http-equiv='Refresh' content='5; url=/' />");
  stranka += F("&lt;title>WiFi thermostat - ESP32 - data processing&lt;/title>");
  stranka += F("&lt;/head>");
  stranka += F("&lt;body>");
  stranka += F("&lt;center>&lt;h3>Server received datas from HTML form:&lt;/h3>");
  stranka += "&lt;li>&lt;b>Target temperature: &lt;/b>" + String(read_String(10)) + " °C&lt;/li>";
  stranka += "&lt;li>&lt;b>Hysteresis: &lt;/b>" + String(read_String(100)) + " °C&lt;/li>";
  stranka += F("&lt;b>Redirecting... Please wait&lt;/b>&lt;/center>");
  stranka += F("&lt;/body>");
  stranka += F("&lt;/html>");
  server.send(200, "text/html", stranka);
}

void handleGet() {
  String stranka = "{\n";
  stranka += F("\"Hysteresis\":");
  stranka += String(read_String(100));
  stranka += F(",\n");
  stranka += F("\"Target_Temperature\":");
  stranka += String(read_String(10));
  stranka += F(",\n");
  stranka += F("\"Actual_Temperature\":");
  stranka += String(teplota) + "\n";
  stranka += F("}\n");
  server.send(200, "application/json", stranka);
}

void setup() {
  Serial.begin(115200);
  WiFiManager wifiManager;
  wifiManager.autoConnect("WiFi_TERMOSTAT_AP");
  EEPROM.begin(512);  //Initialize EEPROM
  float a = read_String(10);
  float b = read_String(100);
  if (isnan(a)) {
    writeString(10, 20.25);
  }
  if (isnan(b)) {
    writeString(100, 0.25);
  }
  sensorsA.begin();
  pinMode(rele, OUTPUT);
  digitalWrite(rele, HIGH);
  sensorsA.requestTemperatures();
  delay(750);
  Serial.println(F("Webapp created by: Martin Chlebovec"));
  Serial.println(F("Build 1.0.4 from 10. Oct 2021"));
  Serial.println(F("WiFi connected."));
  Serial.println(F("IP address of WiFi thermostat: "));
  Serial.println(WiFi.localIP());
  if (!MDNS.begin("wifi-termostat")) {
    Serial.println("Error setting up MDNS responder!");
    while (1) {
      delay(1000);
    }
  }
  Serial.println("mDNS responder running");
  Serial.println(F("Thermostat available at: http://wifi-termostat.local"));
  server.on("/", handleRoot);
  server.on("/get_data.json", handleGet);
  server.on("/action.html", HTTP_POST, handleBody);
  server.begin();
  MDNS.addService("http", "tcp", 80);
}

void loop() {
  if ((millis() - cas) >= 10000 || cas == 0) {
    cas = millis();
    teplota = sensorsA.getTempCByIndex(0);
    Serial.println();
    Serial.println(F("----------------------------------------------"));
    Serial.print(F("IP address of WiFi Thermostat: "));
    Serial.print(WiFi.localIP());
    Serial.print(F(", to access WiFi thermostat, visit http://"));
    Serial.print(WiFi.localIP());
    Serial.println(F("/"));
    Serial.println(F("Thermostat also available at: http://wifi-termostat.local via mDNS record"));
    Serial.print(F("Free HEAP: "));
    Serial.print(ESP.getFreeHeap());
    Serial.println(F(" B"));
    Serial.print(F("Current temperature: "));
    Serial.print(String(teplota));
    Serial.println(F(" °C"));
    sensorsA.requestTemperatures();
    float cielova_teplota = read_String(10);
    float  hystereza = read_String(100);
    float minus_hystereza_teplota = (-1 * hystereza);
    float rozdiel = cielova_teplota - teplota; //21 - 20
    if (rozdiel > hystereza) {
      Serial.println(F("Output on"));
      stav = "ON";
      digitalWrite(rele, LOW);
    } else if (rozdiel &lt; minus_hystereza_teplota) {
      Serial.println(F("Output off"));
      stav = "OFF";
      digitalWrite(rele, HIGH);
    } else {
      Serial.println(F("Difference between target and actual temp is not above or below the hysteresis. The output state does not change."));
      Serial.print(F("Actual state of output: "));
      Serial.println(stav);
    }
  }
  server.handleClient();
  yield();
}
</pre>
</div>
</div>
</body>
        <script>
$(document).ready(function(){
  $('[data-toggle="tooltip2"]').tooltip();   
});
</script>
</html>
