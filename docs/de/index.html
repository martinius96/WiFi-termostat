<!DOCTYPE html>
<html lang="de-DE">
<head>
	<!-- Primary Meta Tags -->
	<title>Smartes WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Effiziente Kesselsteuerung im Automatikmodus mit Hysterese</title>
	<meta name="description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Intelligentes Thermostat für effiziente Hausheizung mit präziser Gaskesselsteuerung.">
	<meta name="keywords" content="termostat, digitálny, arduino ide, wemos d1 mini, nodemcu, wifi, esp8266, vykurovanie, kúrenie, wifimanager, webserver, socket, http, web, ip, ipv4, ds18b20, onewire, 1-wire, esp32, nodemcu">
	<!-- Open Graph / Facebook -->
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://martinius96.github.io/WiFi-termostat/de/">
	<meta property="og:title" content="Smartes WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Effiziente Kesselsteuerung im Automatikmodus mit Hysterese">
	<meta property="og:description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Intelligentes Thermostat für effiziente Hausheizung mit präziser Gaskesselsteuerung.">

	<!-- Twitter -->
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://martinius96.github.io/WiFi-termostat/de/">
	<meta property="twitter:title" content="Smartes WiFi-Thermostat - ESP8266 / ESP32 - Webserver - Effiziente Kesselsteuerung im Automatikmodus mit Hysterese">
	<meta property="twitter:description" content="Raumthermostat entwickelt auf der Espressif-Plattform - ESP8266 / ESP32. Intelligentes Thermostat für effiziente Hausheizung mit präziser Gaskesselsteuerung.">
	
	<link rel="icon" type="image/png" href="favicon.png">
	<link rel="sitemap" type="application/xml" title="Sitemap" href="../../sitemap.xml" />
	<meta name="google-site-verification" content="UwZZh2EXv3iWUAi_1Z0hLxVCz6ySJ4UdY_BPoLtejwo" />    	
	<meta property='fb:admins' content='100001242570317'>
    	<meta charset="utf-8">
    	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
    <script src = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/arduino-light.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/languages/arduino.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>    
			 <style>
  pre {
  counter-reset: line-numbering;
  background: #2c3e50;
  padding: 12px 0px 14px 0;
  color: #ecf0f1;
  line-height: 100%;
}

pre .line::before {
  content: counter(line-numbering);
  counter-increment: line-numbering;
  padding-right: 1em;
  /* space after numbers */
  padding-left: 8px;
  width: 1.5em;
  text-align: right;
  opacity: 0.5;
  color: white;
}
  </style>   
		<style>
	#right {
  position: absolute;
  right: 0px;
}
	</style>
</head>
<body>
	<div class="container">
  		<div class="row">
    			<div class="col-sm-12">
<nav class="navbar navbar-inverse">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="index.html">WiFi Thermostat</a>
    </div>
    <ul class="nav navbar-nav">
      	<li class="active"><a href="index.html">Überblick</a></li>
	<li><a href="zapojenie.html">Beteiligung</a></li>      
	<li class=""><a href="spustenie.html">Firmware</a></li>
  	<li><a href="json_client.html">JSON-Client</a></li>
      	<li><a href="kontakt.html">Kontakt</a></li>
<a href="../index.html"><img src="https://futbalovysen.sk/wp-content/uploads/slovakia.png" alt="Slovak flag.png, 2,2kB" title="Slovakia" height="32" width="32"></a>	
<a href="../en/index.html"><img src="https://i2.wp.com/facsusa.com/wp-content/uploads/2017/05/Flag-of-England.png?ssl=1" alt="English.png, 2,2kB" title="English" height="32" width="32"></a>
	<li style="float: right; "><a href="https://martinius96.github.io/termostat-ethernet/de/" class="btn btn-danger" role="button" title="Ändern Sie das Projekt in einen Ethernet-Thermostat"><img src="https://i.imgur.com/6dW9TvK.png" width=16px height=16px> <font color="white">Ethernet-Thermostat</font></a></li>
    </ul>
  </div>
</nav>  
<div class="alert alert-success">
	<strong>WiFi-Thermostat-Projekt-Repository mit Maschinencodes für die Zielplattform ESP8266 und ESP32: </strong><a href="https://github.com/martinius96/WiFi-termostat/">Github repo</a>
</div>	
<div class="alert alert-danger">
	Die Firmware WiFi_Thermostat und WiFi_Thermostat_mDNS ist in englischer Sprache für die Mikrocontroller ESP32 und ESP8266 (Espressif Systems) verfügbar. Die experimentelle Version der Basis-Firmware mit manueller Ausgabesteuerung ist nur in slowakischer Sprache verfügbar.
</div>	
<div class="alert alert-info">
 	<strong>Unterstützen Sie das WiFi-Thermostat-Projekt über PayPal. Der Support ermöglicht es Ihnen, in Zukunft neue Funktionen hinzuzufügen und den Quellcode der Anwendung zu öffnen: </strong><a href="https://www.paypal.com/paypalme/chlebovec" class="btn btn-primary" role="button">PayPal donate</a>
</div>	
<span class="label label-default">ESP8266</span>
<span class="label label-primary">ESP32</span>
<span class="label label-success">WiFi</span>
<span class="label label-info">DS18B20</span>
<span class="label label-warning">OneWire</span>
<span class="label label-danger">Dallas</span>
<span class="label label-default">HTML</span>
<span class="label label-primary">Webserver</span>
<span class="label label-success">WebSocket</span>
<span class="label label-info">JSON</span>
<span class="label label-warning">mDNS</span>	
<span class="label label-danger">UART</span>					
  <div class="row">
  <div class="col-sm-4"><center><img src="https://i.imgur.com/koSyFuW.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuern NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F" title="Mikrocontroller steuern NodeMCU v2 / v3 Lolin - ESP8266-12E / ESP8266-12F"><br><b><a href="https://www.ebay.com/itm/252718027546">NodeMCU (ESP8266)</a></b></center></div>
  <div class="col-sm-4"><center><img src="https://i.imgur.com/FV9xi6K.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuern Wemos D1 Mini - ESP8266-12E / ESP8266-12F" title="Mikrocontroller steuern Wemos D1 Mini - ESP8266-12E / ESP8266-12F"><br><b><a href="https://www.ebay.com/itm/254535886946">Wemos D1 Mini (ESP8266)</a></b></center></div>
  <div class="col-sm-4"><center><img src="https://i.imgur.com/BczG03b.png" width="128px" height="128px" style="border-radius: 50%;" alt="Mikrocontroller steuernr ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S" title="Mikrocontroller steuern ESP32 Devkit V1 - ESP-WROOM-32 / ESP32-S"><br><b><a href="https://www.ebay.com/itm/254953129496">ESP32 DevKit</a></b></center></div>
</div>					
<hr><center><h2>WiFi Thermostat - ESP8266 / ESP32</h2></center><hr>
<p style="text-align: justify;">
Die Softwareimplementierung ist speziell für Mikrocontroller-Plattformen von Espressif Systems mit WiFi-Konnektivität konzipiert. Sie unterstützt WiFi (2,4 GHz) auf ESP8266- und ESP32-Mikrocontrollern.
Der WiFi-Thermostat ist über das LAN-Netzwerk zugänglich und mit einer Weboberfläche ausgestattet. Diese dient der Konfiguration aller Thermostatelemente und ermöglicht gleichzeitig die Visualisierung der aktuellen Zustände.
Der Thermostat steuert den Kessel basierend auf der gemessenen Solltemperatur und einer Hysterese. Diese Regelung erfolgt unabhängig von der Webapplikation, die für die Konfiguration und Entscheidungsschwelle des Thermostats dient.
Zusätzlich zur Verfügbarkeit des Thermostats unter einer bestimmten IP-Adresse kann der Thermostat durch einen mDNS-Record ergänzt werden. Dieser generiert eine lokale Domain (hostname.local) innerhalb des Multicast-Dienstes, die nur im LAN-Netzwerk erreichbar ist.
Die Konfiguration des Thermostats im Heim-WLAN-LAN-Netzwerk wird durch den WiFiManager gesichert. Dieser speichert die WLAN-Netzwerkdaten (SSID und Passwort) im Flash-Speicher des Mikrocontrollers. Die Konfiguration wird einmalig durchgeführt, und das Gerät merkt sich die Einstellungen dauerhaft. Nach erfolgreicher Konnektivität (Zuweisung einer IP-Adresse durch den Router des WLAN-Heimnetzwerks) ist der Thermostat vollständig einsatzbereit.
Der HTTP-Webserver auf dem ESP8266/ESP32-Mikrocontroller ermöglicht das Ausführen mehrerer unabhängiger HTML-Seiten. Diese können informativ oder sogar funktional gestaltet sein.
</p>
<b>In Bezug auf die Hardware verwendet das Projekt:</b>
<li>ESP8266 / ESP32</li>
<li>Temperatursensor DS18B20 am OneWire-Bus</li>
<li>Relais SRD-5VDC-SL-C / OMRON G3MB-202P zur Kesselschaltung (Active-LOW-Signal)</li>
<hr>
<b> HTML-Seiten mit ESP8266 / ESP32: </b>
<li> <b> / </b> - Grundseite mit Formular, aktueller Logikausgang für das Relais, aktuelle und Solltemperatur, Hysterese </li>
<li> <b> /action.html </b> - verarbeitet Werte aus dem Formular, schreibt sie in den emulierten EEPROM-Speicher, leitet den Benutzer zurück zur Stammseite </li>
<li> <b> /get_data.json </b> - verteilt Daten zur aktuellen Temperatur, Referenztemperatur und Hysterese an Dritte (Computer, Mikrocontroller, anderer Client ...) im JSON-Format - kann mit dem Beispiel verwendet werden JSON-Client, der Daten an MQTT Broker senden kann, zum Beispiel an die Hausautomation </li>
<hr>
<b> Erweitert mit HTML-Seiten in einer experimentellen Version mit manuellem Modus, falls vorhanden: </b>
<li> <b> /on.html </b> - Ausgabe im manuellen Modus dauerhaft einschalten </li>
<li> <b> /vyp.html </b> - Ausgabe im manuellen Modus dauerhaft deaktivieren </li>
<li> <b> /automat.html </b> - Modus auf Automatik ändern (verwendet Hysterese und Zieltemperatur) </li>
<li> <b> /manual.html </b> - Wechseln Sie in den manuellen Modus (permanente EIN / AUS-Hardsteuerung) </li>
<hr>	
<p style="text-align: justify;">		
<b>Die Auflösung des DS18B20-Sensors beträgt während der Messung 12 Bit, was eine Temperaturauflösung von 0,0625 °C ergibt, was gleichzeitig der minimale Schritt zwischen den verschiedenen Messwerten ist. Daten über den OneWire-Bus können bei Bedarf in 500 bis 1000 ms an den Mikrocontroller zurückgesendet werden, abhängig von der Anzahl der Sensoren und der Buslänge.</b>
<b>Das im Projekt verwendete elektromagnetische Relais SRD-5VDC-SL-C ermöglicht das Schalten bis zu 10A bei 230V, was einer Leistung von 2300W entspricht. Beim Schalten eines Gleichstromkreises (Last) können 300W (10A bei 30V DC) geschaltet werden. Als Alternative ist das OMRON G3MB-202P SSR-Relais voll kompatibel zum Schaltplan, jedoch nur für nicht induktive Lasten und ausschließlich für Wechselstromkreise geeignet, mit einer maximalen Schaltleistung von 460W (230V, 2A).</b>
<b>Der Thermostat ist das ganze Jahr über einsatzbereit. Im Falle einer unnötigen Steuerung besteht die Möglichkeit, den Ausgang physisch zu trennen und den Thermostat als WLAN-Thermometer zu verwenden, um Daten aus dem Raum zu erhalten, in dem er sich befindet.</b>
</p>
<hr>
<p style="text-align: justify;">
Bei einer Firmware mit Unterstützung für die manuelle Steuerung des GPIO-Ausgangs des ESP-Mikrocontrollers kann der Thermostat physisch ausgeschaltet werden, ohne ihn von der Relaisklemme trennen zu müssen. Die Thermostatlogik wird unabhängig vom Webserver und den angeschlossenen Clients alle 10 Sekunden ausgeführt, und es ist keine Keep-Alive-Verbindung erforderlich.
Bei jeder Ausführung der Logik schreibt der Thermostat Informationen über die aktuelle IP-Adresse oder den mDNS-Record (bei Verwendung mit mDNS-Firmware) auf den UART-Thermostat. Dadurch erhält der Benutzer Auskunft darüber, wo der Thermostat mit seinem Webinterface im LAN-Netzwerk erreichbar ist. Zusätzlich listet er den dynamischen freien Speicher (HEAP), der von 40 bis 44 kB reicht, sowie den aktuellen Status der Ausgabe auf, mit Benachrichtigung über Änderungen, falls sie auftreten (z. B. wenn die Entscheidungsschwelle überschritten wird).
<b>Die 3V3-GPIO-Betriebslogik der ESP8266- und ESP32-Mikrocontroller reicht für ein digitales Änderungssignal aus, aber das Relais muss mit 5 V von VUSB bzw. VIN versorgt werden.</b>
</p>
<b> Die Webschnittstelle des WiFi-Thermostats ermöglicht Ihnen: </b>
<li> Sehen Sie in Echtzeit die Temperatur des DS18B20-Sensors, die Betriebszeit des Geräts, den Ausgabewert mit dynamischer Änderung, die aktuell eingestellten Konfigurationsdaten für den Thermostat, d. Solltemperatur und Hysterese </li>
<li>Ändern Sie die Ziel-(Referenz-)Temperatur <del>im Bereich von 5 bis 50 °C in Schritten von 0,25 °C</del> <img src="https://i.imgur.com/zMsp0cr.png" width="20px" height="20px" data-toggle="tooltip2" data-placement="right" title="Umfang in Version 1.0.2 aufgrund der Unterstützung von Nicht-Dezimalkomma für die Eingabetypnummer auf Android-Betriebssystem entfernt"></li>
<li> Ändern <del>Hysterese von 0 bis 10 ° C in Schritten von 0,25 ° C</del> <img src="https://i.imgur.com/zMsp0cr.png" width="20px" height="20px" data-toggle="tooltip2" data-placement="right" title="Umfang in Version 1.0.2 aufgrund der Unterstützung von Nicht-Dezimalkomma für die Eingabetypnummer auf Android-Betriebssystem entfernt"></li>
<div class="alert alert-danger">
  <strong>Die Programmimplementierung eines Thermostats mit automatischer und manueller Leistungsregelung ist experimentell!</strong>
</div>
<b> Kessel EIN / AUS-Steuerung - Automatikmodus: </b>
<li>Beispiel für EIN / AUS der Heizungssteuerung - <font color = "red"> VISUALISIERUNG IST NICHT TEIL DES PROJEKTS </font> </li>
<li>Der Kessel ist aktiv, solange die Solltemperatur + Hysterese erreicht ist </li>
<li> Die Visualisierung von Wassertemperaturen zeigt die sogenannte Heizlauf und anschließendes Abkühlen des Wassers bis die Heizung wieder aktiviert wird, wenn die gemessene Temperatur unter der eingestellten Solltemperatur liegt - Hysterese </li>
<img src="https://i.imgur.com/IDWLuOr.png" style="display: block; max-width: 100%; height: auto;" alt="ZAP/VYP regulácia kotla s hysterézou" title="ZAP/VYP regulácia kotla s hysterézou">   
<p style="text-align: justify;">
<b> In der Basisversion des WiFi-Thermostats (ohne mDNS-Aufzeichnung) wurde ein manueller Steuermodus (hart EIN / AUS) implementiert mit der Möglichkeit zwischen manuellem und automatischem Modus umzuschalten. </b>
Die Weboberfläche ist für größere und kleinere Bildschirme ausgelegt. Es ist reaktionsschnell und unterstützt hochauflösende Breitbild-Bildschirme sowie mobile Geräte.
Die Schnittstelle verwendet importierte CSS-Stile des Bootstrap-Frameworks von einem externen CDN-Server, der das clientseitige Gerät lädt, wenn eine Seite geöffnet wird, die auf ESP ausgeführt wird.
Durch den Import von CSS-Stilen von einem externen Server wird die Strom- und Speicherbelastung des Mikrocontrollers reduziert.
</p>
<hr>
<p style="text-align: justify;">
Um die eingestellten Werte des Thermostats auch nach einem Stromausfall zu bewahren, werden diese im EEPROM-Speicher des ESP gespeichert, der im Flash-Speicher emuliert wird, da die Plattform keinen physischen EEPROM-Chip besitzt. Die Referenztemperatur wird am Offset 10 gespeichert, die Hysterese am Offset 100. Jeder der Werte belegt maximal 5 Bytes im EEPROM-Speicher, zusätzlich zum Endzeichen.
Die Daten werden erst beim Senden des HTML-Formulars überschrieben, und der Betrieb des Thermostats schont den EEPROM-Speicher für maximale Haltbarkeit. Der Zustand des Ausgangs existiert nur im RAM-Speicher, wo er bei Änderungen überschrieben wird. Der Wert wird nicht im emulierten EEPROM-Speicher im Flash-Speicher abgelegt.
</p>
<hr>
<p style="text-align: justify;">
Wenn das Gerät beim ersten Start keine Daten auf den genannten EEPROM-Offsets gespeichert hat, erfolgt automatisch ein Schreiben mit Standardwerten: Referenztemperatur 20,25 °C und Hysterese 0,00 °C. Dadurch wird sichergestellt, dass der Thermostat auf Mikrocontrollern arbeiten kann, die keine vorherigen Werte im EEPROM-Speicher gespeichert haben - eine ausfallsichere Lösung.
ESP8266 und ESP32 verwenden die Funktion EEPROM.put() zum Schreiben in den EEPROM-Speicher, der jeden Datentyp unterstützt. Um das Schreiben in den Ziel-Offset zu bestätigen, wird EEPROM.commit() verwendet. Die Implementierung verwendet den Datentyp float() für eine 32-Bit-Zahl, die im EEPROM gespeichert wird und zur Referenz-(Soll-)Temperatur sowie zur Hysterese gehört.
Mit dem Refresh-Meta-Tag aktualisiert der Webserver alle 30 Sekunden die gesamte HTML-Seite, und die JavaScript-Zeit bis zum Refresh wird ebenfalls per JavaScript in die HTML-Seite geschrieben. Zu diesem Zeitpunkt ist es notwendig, die Änderung für den Thermostaten zu schreiben, da sonst die Eingabefenster für numerische Eingaben im Formular beim Aktualisieren der Seite zurückgesetzt werden.
Da die eingebaute Ethernet-Bibliothek die Verwendung eines asynchronen Webservers nicht beinhaltet (der beispielsweise mit den Espressif ESP8266/ESP32-Mikrocontrollern verwendet werden kann), ist es erforderlich, die gesamte Seite neu zu schreiben, da diese Implementierung 1:1 mit dem originalen Ethernet-Thermostat ist.
</p>
<hr>
<p style="text-align: justify;">
Die sich hauptsächlich ändernden dynamischen Daten betreffen den aktuellen Wert der Ausgabe - <b><font color="#27AE60">EIN</font></b> / <b><font color="red">AUS</font></b>, der dem Bediener den aktuellen Zustand der Ausgabe zusammen mit der Farbcodierung zeigt. Es ist zu beachten, dass die Systemlogik unabhängig vom Webserver arbeitet, daher kann sich die Ausgabe bereits in einem anderen Zustand befinden als in der Webanwendung aufgeführt. Eine Änderung der Ausgabe wird beispielsweise sofort auf den UART-Monitor geschrieben.
Auf der Website des Thermostats findet der Benutzer auch Informationen über die Betriebszeit des Geräts, wie lange es bereits in Betrieb war, angegeben in Tagen, Stunden, Minuten und Sekunden.
<b>Der Thermostat ist ausschließlich für Innentemperaturen gedacht (über 0°C), an die die Systemlogik angepasst ist!</b>
Der Thermostat kann vielseitig eingesetzt werden, beispielsweise um einen vorhandenen Raumthermostat zu ersetzen. Auch die Heizung im Aquarium oder Terrarium kann vorübergehend durch den Thermostat ersetzt werden, um eine konstante Temperatur aufrechtzuerhalten.
</p>
<div class="alert alert-danger">
	<strong>Der Autor des WiFi-Thermostats übernimmt keine Verantwortung für die Funktionalität des Thermostats, Ausfälle des Kessels oder Stromschläge aufgrund unsachgemäßer Installation des Thermostats im Netzwerk. </strong>
</div>	
<b> Hauptseite zur Änderung der Zieltemperatur und der Hysterese - Demo auf: </b>
<div class="alert alert-info">
	<strong> Beispieldaten </strong>
<li> <b>Zieltemperatur: </b> 22.75 °C</li>
<li> <b> Hysterese: </b> 0.25 ° C </li>
<li> <b>Messdaten: </b> 22.49 ° C </li>
<li> <b> Ausgabe: </b>  <font color="#27AE60">EIN</font></li>
	<hr>
	<p style="text-align: justify;">
		Der Thermostat heizt ab einer gemessenen Temperatur von 22.49 °C und darunter.
Wenn die Temperatur 23.01 °C erreicht, wird der Ausgang ausgeschaltet, das Melderelais öffnet und der Gaskessel hört auf zu heizen.
Das Aufheizen und Abkühlen des Raumes, in dem die Messungen durchgeführt werden, erfolgt. 
Der Thermostat wird erst wieder aktiviert, wenn die Temperatur 22.49 °C oder niedriger erreicht.
	</p>	
</div>

<b>Hauptseite zur Änderung der Solltemperatur und Hysterese:</b>
<img src="https://i.imgur.com/dBXiDLN.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi-Thermostat - Hauptübersicht mit Änderung von Solltemperatur und Hysterese" title="WiFi-Thermostat - Hauptübersicht mit Änderung von Solltemperatur und Hysterese">        			

<b>Verarbeitungsprozess der eingegebenen Daten (Nutzerumleitung):</b>
<img src="https://i.imgur.com/QaGCYGh.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi-Thermostat - Datenverarbeitung aus HTML-Formular" title="WiFi-Thermostat - Datenverarbeitung aus HTML-Formular">        			

<b>JSON-Webserverausgabe im Browser / Client über Websocket:</b>
<center><img src="https://i.imgur.com/iqxV12k.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi thermostat - JSON output" title="WiFi thermostat - JSON output"></center>        		

<b>Ausgabe an UART-Monitor - Systemlogik + IP-Adresse einstellen, mDNS-Record:</b>
<center>
<img src="https://i.imgur.com/gWm9izE.png" style="display: block; max-width: 100%; height: auto;" alt="WiFi termostat - UART - ESP8266 - mDNS protokollieren, IP-Adresse des Thermostats" title="WiFi termostat - UART - ESP8266 - mDNS protokollieren, IP-Adresse des Thermostats">
</center>        		
<div class="alert alert-info">
<b> Eine erweiterte Version des WiFi-Thermostats umfasst: </b>
<li> Bearbeitbarer Quellcode (.ino) </li>
<li> Verfügbare Sensoren SHT21, SHT31, DHT22, BME280, BMP280 für die Kesselsteuerung </li>
<li> Kühlmodus (inverse Logik zum Heizthermostat) </li>
<li> Basic OTA, OTA Web Updater, Eleganter Remote OTA </li>
<li> Möglichkeit, die Ausgabe über Callbacks zu steuern, die von UDP-Datagrammen über UDP-Clients (Packet Sender) aufgerufen werden. </li>
<li> Interaktion mit Amazon Alexa Echo Dot mit der Möglichkeit der Sprachsteuerung des Thermostats (UDP-Rückrufe) </li>
<li> Möglichkeit zur Veröffentlichung von Daten an MQTT Broker / per HTTP / HTTPS-Anfrage an einen entfernten Webserver mit Datenspeicherung in einer MySQL-Datenbank (ohne JSON-Client) </li>
</div>
<hr><center><h4>Verfügbare Bibliotheken für Mikrocontroller (ESP)</h4></center><hr>
<div class="alert alert-danger">
	Bibliotheksarchiv (.zip) expandieren zu <strong>C:/Users/[User]/Documents/Arduino/libraries</strong>
</div>
<div class="table-responsive">   
<table class="table" style="border: 1px solid black;">
<thead>
<tr>
<th style="width: 25%">Name der Bibliothek</th>
<th style="width: 50%">Bibliotheksfunktion</th>
<th style="width: 25%">Herunterladen</th>
</tr>
</thead>
<tbody>
<tr>
<td style="width: 25%"><b>Dallas</b></td>
<td style="width: 50%">
<p style="text-align: justify;">
Bibliothek für ESP8266- und ESP32-Mikrocontroller.
Es ermöglicht die Kommunikation mit dem Dallas DS18B20-Sensor auf dem OneWire-Bus. Kommunikationsmöglichkeit nach normaler oder parasitärer Verbindung. 
</p>
</td>
<td style="width: 25%"><a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/martinius96/termostat-ethernet/tree/master/src/dallas" class="btn btn-success" role="button">Herunterladen</a></td>
</tr>
<tr>
<td style="width: 25%"><b>WiFiManager</b></td>
<td style="width: 50%">
<p style="text-align: justify;">
Bibliothek für ESP8266- und ESP32-Mikrocontroller.
Erstellt einen Zugangspunkt (AP) und ein Captive-Portal zum Konfigurieren eines WLAN-Thermostats in einem WLAN-Heimnetzwerk.
</p>
</td>
<td style="width: 25%"><a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/martinius96/WiFi-termostat/tree/main/src/WiFiManager-0.16.0" class="btn btn-success" role="button">Herunterladen</a></td>
</tr>
<tr>
<td style="width: 25%"><b>DNS Server</b></td>
<td style="width: 50%">
<p style="text-align: justify;">
ESP32-Mikrocontroller-Bibliothek.
Erforderlich, damit die WiFiManager-Bibliothek ordnungsgemäß funktioniert. 
</p>
</td>
<td style="width: 25%"><a href="https://minhaskamal.github.io/DownGit/#/home?url=https://github.com/martinius96/WiFi-termostat/tree/main/src/DNSServer---esp32-master" class="btn btn-success" role="button">Herunterladen</a></td>
</tr>
</tbody>
</table>
</div>

</div>
</div>
</body>
        <script>
$(document).ready(function(){
  $('[data-toggle="tooltip2"]').tooltip();   
});
</script>
</html>
